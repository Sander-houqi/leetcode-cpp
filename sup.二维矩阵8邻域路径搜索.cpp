

#include<vector>
#include<iostream>

using namespace std;

class Solution{
public:

    //八邻域搜索    
    vector<int> direction{-1,1,1,-1,-1,0,1,0,-1};

    vector<vector<int>> get_path(vector<vector<char>>& grid){

		int m = grid.size() , n = grid[0].size();
		vector<vector<int>> ans;
        vector<vector<int>> path;
        bool flag = false;
		dfs(grid,ans,path,flag,0,0);
		return ans;

	}

	void dfs(vector<vector<char>>& grid, vector<vector<int>>& ans, vector<vector<int>> & path, bool &flag, int l ,int c){
        // 已经访问过，遇到墙壁，或者已经获得路径的返回。
		if(grid[l][c]=='+' || grid[l][c]=='1' || flag) return;

        if (grid[l][c]=='*'){
            //获得一条路径即可
            ans = path;
            //是否获得路径的标志位
            flag = true;
            return;
        }

        //已经访问过的置为1
		grid[l][c] = '1';
		int x,y;
		for(int k=0; k<direction.size(); ++k){
			x = l + direction[k]; y = c +direction[k+1];
			if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){
                
				path.push_back({l,c});
				dfs(grid,ans,path,flag,x,y);
                //回溯
				path.pop_back();
			}

		}

	}

};


int main(){

    // 二维矩阵，从（0，0）出发，+ 表示墙壁，*表示终点，求一条从出发到终点的路径，可能有多条，选择一条即可。
    vector<vector<char>> grid={
        {'0','+','0','0','0','0','0','0','+','*','+','+','+','+','+','+','+','+','+'},
        {'0','+','+','+','0','+','0','0','+','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','+','0','+','0','0','+','+','+','+','+','+','+','+','+','+','0'},
        {'+','0','0','0','0','+','0','0','+','0','0','0','0','0','0','0','0','0','0'},
        {'+','+','+','+','+','+','0','0','+','0','0','0','0','+','+','+','+','+','+'},
        {'0','0','0','0','0','0','0','0','+','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','+','0','0','+','+','+','+','+','+','+','+','+','+','0','0'},
        {'0','0','0','0','+','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','+','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','+','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','+','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','+','0','+','+','+','+','+','+','+','+','+','+','+','+','+'},
        {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','0','0','0','0','0','0','+','+','+','+','+','+','+','+','+'},
        {'0','0','0','0','0','0','0','0','0','0','+','+','0','0','0','0','0','0','0'},
        {'0','0','0','0','0','+','+','+','+','+','+','+','0','0','0','0','0','0','0'},
        {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'},
        {'0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0'}, 
    };

    vector<vector<int>> result = Solution().get_path(grid);
    
    //遍历grid 可以看到最后访问了哪些节点
    //遍历result 可以输出最后选择的路径
    for(const auto &row : grid ){
        for ( const auto &s : row ) {
            std::cout << s << ' ';
        }
        std::cout << std::endl;
    }

    return 0;
}